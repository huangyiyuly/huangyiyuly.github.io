<!DOCTYPE html><html lang="cn"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>ThreadLocal(JDK1.8)刨析 | 四火的博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ThreadLocal(JDK1.8)刨析</h1><a id="logo" href="/.">四火的博客</a><p class="description">yuly's blog</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">ThreadLocal(JDK1.8)刨析</h1><div class="post-meta">Nov 6, 2019</div><div class="post-content"><h2 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h2><p>下图ThreadId类会在每个线程中生成唯一标识符。线程的id在第一次调用threadid.get()时被分配，在随后的调用中保持不变。<br>ThreadId类利用AtomicInteger原子方法getAndIncrement(CAS)，为每个线程创建一个threadId变量，例如第一个线程是1，第二个线程是2…，并提供一个类静态get方法用以获取当前线程ID。</p>
<p>源码解析如下:<br><img src="/images/threadLocalDesc.jpg" alt></p>
<p>翻译之后:</p>
<p>ThreadLocal类用来提供线程内部的局部变量。<br>这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。<br>ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。</p>
<p>可以总结为:<br>ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。</p>
<h2 id="ThreadLocal如何设计"><a href="#ThreadLocal如何设计" class="headerlink" title="ThreadLocal如何设计"></a>ThreadLocal如何设计</h2><p>知道定义之后，如果让你来设计这个功能你会怎么设计，是不是会在每个ThreadLocal类创建一个Map，<br>然后用线程的ID作为Map的key，实例对象作为Map的value，这样就能达到各个线程的值隔离的效果。<br>废话不多说我们看下JDK1.8是如何设计的.</p>
<h3 id="ThreadLocal-get方法"><a href="#ThreadLocal-get方法" class="headerlink" title="ThreadLocal#get方法"></a>ThreadLocal#get方法</h3><p><img src="/images/threadLocalInit.jpg" alt></p>
<p>创建对下的时候,什么初始化都没有操作,通过定义可以猜到真正起作用的是get和set方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value in the current thread's copy of this</span></span><br><span class="line"><span class="comment">     * thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment">     * current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment">     * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the current thread's value of this thread-local</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Variant of set() to establish initialValue. Used instead</span></span><br><span class="line"><span class="comment">      * of set() in case user has overridden the set() method.</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span> the initial value</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         T value = initialValue();</span><br><span class="line">         Thread t = Thread.currentThread();</span><br><span class="line">         ThreadLocalMap map = getMap(t);</span><br><span class="line">         <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">             map.set(<span class="keyword">this</span>, value);</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             createMap(t, value);</span><br><span class="line">         <span class="keyword">return</span> value;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Get the map associated with a ThreadLocal. Overridden in</span></span><br><span class="line"><span class="comment">       * InheritableThreadLocal.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span>  t the current thread</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> the map</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">      &#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Get the entry associated with key.  This method</span></span><br><span class="line"><span class="comment">         * itself handles only the fast path: a direct hit of existing</span></span><br><span class="line"><span class="comment">         * key. It otherwise relays to getEntryAfterMiss.  This is</span></span><br><span class="line"><span class="comment">         * designed to maximize performance for direct hits, in part</span></span><br><span class="line"><span class="comment">         * by making this method readily inlinable.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span>  key the thread local object</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the entry associated with key, or null if no such</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">            Entry e = table[i];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">     </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Create the map associated with a ThreadLocal. Overridden in</span></span><br><span class="line"><span class="comment">      * InheritableThreadLocal.</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> firstValue value for the initial entry of the map</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">         t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocalMap才是主角，其地位图示:</p>
<p><img src="/images/threadLocalFlow.jpg" alt></p>
<p>代码看到这里可以发现内部确实是有一个 Entry[]的数组进行存储,这个数组的内部结构是一个key-value的结构.并且该对象是一个弱引用。<br>总所周知：引用总共分为四种强引用，弱引用，软引用，虚引用。<br>StrongReference 是 Java 的默认引用实现,  它会尽可能长时间的存活于 JVM 内， 当没有任何对象指向它时 GC 执行后将会被回收。<br>WeakReference， 顾名思义,  是一个弱引用,  当所引用的对象在 JVM 内不再有强引用时, GC 后 weak reference 将会被自动回收。<br>SoftReference 于 WeakReference 的特性基本一致， 最大的区别在于 SoftReference 会尽可能长的保留引用直到 JVM 内存不足时才会被回收(虚拟机保证), 这一特性使得 SoftReference 非常适合缓存应用。<br>PhantomReference 主要用来跟踪对象被垃圾回收器回收的活动，用于对象被回收前的清理工作。他一般和ReferenceQueue配合使用，当PhantomReference指向的对象被jvm回收时，jvm就会把PhantomReference加入到ReferenceQueue中，之后你还要手动释放ReferenceQueue里的内存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">        * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">        * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">        * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">        * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">        * as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">           <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">           Object value;</span><br><span class="line"></span><br><span class="line">           Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">               <span class="keyword">super</span>(k);</span><br><span class="line">               value = v;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The initial capacity -- MUST be a power of two.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The table, resized as necessary.</span></span><br><span class="line"><span class="comment">        * table.length MUST always be a power of two.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">private</span> Entry[] table;</span><br></pre></td></tr></table></figure>

<p>简单解析一下，get方法的流程是这样的：</p>
<h4 id="1-首先获取当前线程"><a href="#1-首先获取当前线程" class="headerlink" title="1:首先获取当前线程"></a>1:首先获取当前线程</h4><h4 id="2-根据当前线程获取一个Map"><a href="#2-根据当前线程获取一个Map" class="headerlink" title="2:根据当前线程获取一个Map"></a>2:根据当前线程获取一个Map</h4><h4 id="3-如果获取的Map不为空，则在Map中以ThreadLocal的引用作为key来在Map中获取对应entry的value-否则转到5"><a href="#3-如果获取的Map不为空，则在Map中以ThreadLocal的引用作为key来在Map中获取对应entry的value-否则转到5" class="headerlink" title="3:如果获取的Map不为空，则在Map中以ThreadLocal的引用作为key来在Map中获取对应entry的value,否则转到5"></a>3:如果获取的Map不为空，则在Map中以ThreadLocal的引用作为key来在Map中获取对应entry的value,否则转到5</h4><h4 id="4-如果entry不为null，则返回e-value，否则转到5"><a href="#4-如果entry不为null，则返回e-value，否则转到5" class="headerlink" title="4:如果entry不为null，则返回e.value，否则转到5"></a>4:如果entry不为null，则返回e.value，否则转到5</h4><h4 id="5-Map为空或者e为空，则通过initialValue函数获取初始值value，然后用ThreadLocal的引用和value作为firstKey和firstValue创建一个新的Map"><a href="#5-Map为空或者e为空，则通过initialValue函数获取初始值value，然后用ThreadLocal的引用和value作为firstKey和firstValue创建一个新的Map" class="headerlink" title="5:Map为空或者e为空，则通过initialValue函数获取初始值value，然后用ThreadLocal的引用和value作为firstKey和firstValue创建一个新的Map"></a>5:Map为空或者e为空，则通过initialValue函数获取初始值value，然后用ThreadLocal的引用和value作为firstKey和firstValue创建一个新的Map</h4><p>根据上面Entry方法的源码，我们知道ThreadLocalMap是使用ThreadLocal的弱引用作为Key的。下图是本文介绍到的一些对象之间的引用关系图，实线表示强引用，虚线表示弱引用：</p>
<p><img src="/images/threadLocalMapWeak.jpg" alt></p>
<h3 id="ThreadLocalMap-Entry弱引用危害"><a href="#ThreadLocalMap-Entry弱引用危害" class="headerlink" title="ThreadLocalMap#Entry弱引用危害"></a>ThreadLocalMap#Entry弱引用危害</h3><p>如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：<br>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value<br>永远无法回收，造成内存泄露。</p>
<h3 id="ThreadLocal内存泄露解决方案："><a href="#ThreadLocal内存泄露解决方案：" class="headerlink" title="ThreadLocal内存泄露解决方案："></a>ThreadLocal内存泄露解决方案：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Expunge a stale entry by rehashing any possibly colliding entries</span></span><br><span class="line"><span class="comment">        * lying between staleSlot and the next null slot.  This also expunges</span></span><br><span class="line"><span class="comment">        * any other stale entries encountered before the trailing null.  See</span></span><br><span class="line"><span class="comment">        * Knuth, Section 6.4</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> staleSlot index of slot known to have null key</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span> the index of the next null slot after staleSlot</span></span><br><span class="line"><span class="comment">        * (all between staleSlot and this slot will have been checked</span></span><br><span class="line"><span class="comment">        * for expunging).</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">           Entry[] tab = table;</span><br><span class="line">           <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">           tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">           tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">           size--;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">           Entry e;</span><br><span class="line">           <span class="keyword">int</span> i;</span><br><span class="line">           <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">                (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">                i = nextIndex(i, len)) &#123;</span><br><span class="line">               ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">               <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   e.value = <span class="keyword">null</span>;</span><br><span class="line">                   tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                   size--;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                   <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                       tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                       <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                       <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                           h = nextIndex(h, len);</span><br><span class="line">                       tab[h] = e;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> i;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocalMap 也是采用的散列表（Hash）思想来实现的，但是实现方式和 HashMap 不太一样。我们首先看下散列表的相关知识</p>
<p>首先从ThreadLocal的直接索引位置(通过ThreadLocal.threadLocalHashCode &amp; (table.length-1)运算得到)获取Entry e，如果e不为null并且key相同则返回e;</p>
<p>如果e为null或者key不一致则向下一个位置查询，如果下一个位置的key和当前需要查询的key相等，则返回对应的Entry。</p>
<p>否则，如果key值为null，则擦除该位置的Entry，并继续向下一个位置查询。</p>
<p>在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。</p>
<p>仔细研究代码可以发现，set操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。</p>
<p>但是光这样还是不够的，上面的设计思路依赖一个前提条件：要调用ThreadLocalMap的getEntry函数或者set函数。</p>
<p>这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的remove函数，手动删除不再需要的ThreadLocal，防止内存泄露。</p>
<h3 id="ThreadLocal-set方法"><a href="#ThreadLocal-set方法" class="headerlink" title="ThreadLocal#set方法"></a>ThreadLocal#set方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Set the value associated with key.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> key the thread local object</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> value the value to be set</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">           <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">           <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">           <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">           Entry[] tab = table;</span><br><span class="line">           <span class="keyword">int</span> len = tab.length;</span><br><span class="line">           <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                e != <span class="keyword">null</span>;</span><br><span class="line">                e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">               ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                   e.value = value;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   replaceStaleEntry(key, value, i);</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">           <span class="keyword">int</span> sz = ++size;</span><br><span class="line">           <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">               rehash();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Replace a stale entry encountered during a set operation</span></span><br><span class="line"><span class="comment">        * with an entry for the specified key.  The value passed in</span></span><br><span class="line"><span class="comment">        * the value parameter is stored in the entry, whether or not</span></span><br><span class="line"><span class="comment">        * an entry already exists for the specified key.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * As a side effect, this method expunges all stale entries in the</span></span><br><span class="line"><span class="comment">        * "run" containing the stale entry.  (A run is a sequence of entries</span></span><br><span class="line"><span class="comment">        * between two null slots.)</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span>  key the key</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span>  value the value to be associated with key</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span>  staleSlot index of the first stale entry encountered while</span></span><br><span class="line"><span class="comment">        *         searching for key.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">           Entry[] tab = table;</span><br><span class="line">           <span class="keyword">int</span> len = tab.length;</span><br><span class="line">           Entry e;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Back up to check for prior stale entry in current run.</span></span><br><span class="line">           <span class="comment">// We clean out whole runs at a time to avoid continual</span></span><br><span class="line">           <span class="comment">// incremental rehashing due to garbage collector freeing</span></span><br><span class="line">           <span class="comment">// up refs in bunches (i.e., whenever the collector runs).</span></span><br><span class="line">           <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">                (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">                i = prevIndex(i, len))</span><br><span class="line">               <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">                   slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Find either the key or trailing null slot of run, whichever</span></span><br><span class="line">           <span class="comment">// occurs first</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">                (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">                i = nextIndex(i, len)) &#123;</span><br><span class="line">               ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">               <span class="comment">// If we find key, then we need to swap it</span></span><br><span class="line">               <span class="comment">// with the stale entry to maintain hash table order.</span></span><br><span class="line">               <span class="comment">// The newly stale slot, or any other stale slot</span></span><br><span class="line">               <span class="comment">// encountered above it, can then be sent to expungeStaleEntry</span></span><br><span class="line">               <span class="comment">// to remove or rehash all of the other entries in run.</span></span><br><span class="line">               <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                   e.value = value;</span><br><span class="line"></span><br><span class="line">                   tab[i] = tab[staleSlot];</span><br><span class="line">                   tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// Start expunge at preceding stale entry if it exists</span></span><br><span class="line">                   <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                       slotToExpunge = i;</span><br><span class="line">                   cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// If we didn't find stale entry on backward scan, the</span></span><br><span class="line">               <span class="comment">// first stale entry seen while scanning for key is the</span></span><br><span class="line">               <span class="comment">// first still present in the run.</span></span><br><span class="line">               <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">                   slotToExpunge = i;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// If key not found, put new entry in stale slot</span></span><br><span class="line">           tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">           tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// If there are any other stale entries in run, expunge them</span></span><br><span class="line">           <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">               cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>总结set步骤：</p>
<p>1）根据哈希码和数组长度求元素放置的位置，即数组下标</p>
<p>2）从第一步得出的下标开始往后遍历，如果key相等，覆盖value，如果key为null,用新key、value覆盖，同时清理历史key=null的陈旧数据</p>
<p>3）如果超过阀值，就需要再哈希：</p>
<p>清理一遍陈旧数据 &gt;= 3/4阀值,就执行扩容，把table扩容2倍==》注意这里3/4阀值就执行扩容，避免迟滞把老数据重新哈希散列进新table</p>
<h3 id="ThreadLocal-remove方法"><a href="#ThreadLocal-remove方法" class="headerlink" title="ThreadLocal#remove方法"></a>ThreadLocal#remove方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Remove the entry for key.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">           Entry[] tab = table;</span><br><span class="line">           <span class="keyword">int</span> len = tab.length;</span><br><span class="line">           <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">           <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                e != <span class="keyword">null</span>;</span><br><span class="line">                e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">               <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">                   e.clear();</span><br><span class="line">                   expungeStaleEntry(i);</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>所以JDK建议将ThreadLocal变量定义成private static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，<br>所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。</p>
<h3 id="ThreadLocal-resize方法"><a href="#ThreadLocal-resize方法" class="headerlink" title="ThreadLocal#resize方法"></a>ThreadLocal#resize方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Double the capacity of the table.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           Entry[] oldTab = table;</span><br><span class="line">           <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">           <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">           Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">           <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">               Entry e = oldTab[j];</span><br><span class="line">               <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                   <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>); <span class="comment">//计算hash值</span></span><br><span class="line">                       <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)<span class="comment">//如果这个位置已使用</span></span><br><span class="line">                           h = nextIndex(h, newLen); <span class="comment">// 线性往后查下，直到找到一个没有使用的位置</span></span><br><span class="line">                       newTab[h] = e;<span class="comment">//在第一个空节点塞入entry e</span></span><br><span class="line">                       count++;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           setThreshold(newLen); <span class="comment">//设置新的阈值</span></span><br><span class="line">           size = count;</span><br><span class="line">           table = newTab; <span class="comment">//把新table赋值给</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ThreadLocal-rehash方法"><a href="#ThreadLocal-rehash方法" class="headerlink" title="ThreadLocal#rehash方法"></a>ThreadLocal#rehash方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Re-pack and/or re-size the table. First scan the entire</span></span><br><span class="line"><span class="comment">        * table removing stale entries. If this doesn't sufficiently</span></span><br><span class="line"><span class="comment">        * shrink the size of the table, double the table size.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           expungeStaleEntries();<span class="comment">//清理一次陈旧数据，保证数据及时GC</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class="line">           <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">               resize();</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Expunge all stale entries in the table.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           Entry[] tab = table;</span><br><span class="line">           <span class="keyword">int</span> len = tab.length;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">               Entry e = tab[j];</span><br><span class="line">               <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>)</span><br><span class="line">                   expungeStaleEntry(j);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="解决hash冲突"><a href="#解决hash冲突" class="headerlink" title="解决hash冲突"></a>解决hash冲突</h4><p>hash算法种类:<br>1:除法散列法 -&gt;f(k) = k % p （p&lt;=m）<br>2:平方散列法 -&gt;f(k) = (k * k) &gt;&gt; 28 （32位）<br>3:斐波那契散列法  -&gt; f(k) = (k * 2654435769) &gt;&gt; 28 (32位)<br>4:随机数法 -&gt; f(k) = random(k)</p>
<p>解决hash冲突的方法主要有：<br>1：开放定址法<br> Hi=（H（key）+di）%  m   i=1，2，…，n<br> 其中H（key）为哈希函数，m 为表长，di称为增量序列，增量序列的取值方式不同，相应的再散列方式也不同。主要有以下三种：<br> 1):线性探测再散列 dii=1，2，3，…，m-1<br> 这种方法的特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。<br> 2):二次探测再散列  di=12，-12，22，-22，…，k2，-k2    (  k&lt;=m/2 )<br> 这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。<br> 3):伪随机探测再散列 di=伪随机数序列。<br> 具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），并给定一个随机数做起点</p>
<p>2:再哈希法<br> Hi=RH1（key）  i=1，2，…，k<br> 当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。</p>
<p>3:链地址法<br> 这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。<br> 链地址法适用于经常进行插入和删除的情况。</p>
<p>4:建立公共溢出区<br> 将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表</p>
<p>thradLocalMap中使用了斐波那契散列法，来保证哈希表的离散度。而它选用的乘数值即是2^32 * 黄金分割比。<br>使用“开放寻址法”中最简单的“线性探测法”解决散列冲突问题<br> int h = k.threadLocalHashCode &amp; (len - 1);</p>
<h3 id="ThreadLocal的子类InheritableThreadLocal"><a href="#ThreadLocal的子类InheritableThreadLocal" class="headerlink" title="ThreadLocal的子类InheritableThreadLocal"></a>ThreadLocal的子类InheritableThreadLocal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This class extends &lt;tt&gt;ThreadLocal&lt;/tt&gt; to provide inheritance of values</span></span><br><span class="line"><span class="comment"> * from parent thread to child thread: when a child thread is created, the</span></span><br><span class="line"><span class="comment"> * child receives initial values for all inheritable thread-local variables</span></span><br><span class="line"><span class="comment"> * for which the parent has values.  Normally the child's values will be</span></span><br><span class="line"><span class="comment"> * identical to the parent's; however, the child's value can be made an</span></span><br><span class="line"><span class="comment"> * arbitrary function of the parent's by overriding the &lt;tt&gt;childValue&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * method in this class.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Inheritable thread-local variables are used in preference to</span></span><br><span class="line"><span class="comment"> * ordinary thread-local variables when the per-thread-attribute being</span></span><br><span class="line"><span class="comment"> * maintained in the variable (e.g., User ID, Transaction ID) must be</span></span><br><span class="line"><span class="comment"> * automatically transmitted to any child threads that are created.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Josh Bloch and Doug Lea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     ThreadLocal</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p> 这个类扩展ThreadLocal，以提供从父线程到子线程的值的继承:当创建子线程时，子线程会接收父元素所具有值的所有可继承线程局部变量的初始值。正常情况下，子线程的变量值与父线程的相同;然而，子线程可复写childValue方法来自定义获取父类变量。<br> 当变量(例如，用户ID、事务ID)中维护的每个线程属性必须自动传输到创建的任何子线程时，使用InheritableThreadLocal优于ThreadLocal。<br> InheritableThreadLocal对比ThreadLocal唯一不同是子线程会继承父线程变量，并自定义赋值函数。</p>
<p> ##ThreadLocal传递上下文case</p>
<p> 背景：AssetContext这个上下文在多个方法中调用,但是并不是每个发放都有该参数，其中也存在某个函数对AssetContext转换处理，但是最后的一个函数需要用到该对象。</p>
<p> 解决方案：采用Threadlocal+注解</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpContextHolder</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//申明为list&lt;AssetContext&gt;是因为方法中多个地方调用过assetContext</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;List&lt;AssetContext&gt;&gt; ASSET_CONTEXT_THREAD_LOCAL = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AssetContext <span class="title">current</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;AssetContext&gt; assetContexts = ASSET_CONTEXT_THREAD_LOCAL.get();</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(assetContexts)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"缺少上下文Context定义"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ASSET_CONTEXT_THREAD_LOCAL.get().get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行压栈操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> assetContext 操作上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushStack</span><span class="params">(AssetContext assetContext)</span> </span>&#123;</span><br><span class="line">        List&lt;AssetContext&gt; assetContexts = ASSET_CONTEXT_THREAD_LOCAL.get();</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(assetContexts)) &#123;</span><br><span class="line">            ASSET_CONTEXT_THREAD_LOCAL.set(Lists.newArrayList(assetContext));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            assetContexts.add(assetContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行出栈操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">popStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;AssetContext&gt; assetContexts = ASSET_CONTEXT_THREAD_LOCAL.get();</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(assetContexts) &amp;&amp; assetContexts.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            assetContexts.remove(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ASSET_CONTEXT_THREAD_LOCAL.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AssetContext的栈管理切面，当执行 doAction 前会进行压栈操作，执行结束后出栈</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextAspect</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, ContextConvert&gt; converterMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OpContextHolder opContextHolder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent contextRefreshedEvent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 在bean初始化结束之后将所有的上下文的参数存入map中.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        ApplicationContext applicationContext = contextRefreshedEvent.getApplicationContext();</span><br><span class="line">        Map&lt;String, ContextConvert&gt; beanMap = applicationContext.getBeansOfType(ContextConvert.class);</span><br><span class="line">        beanMap.values().forEach(converter -&gt;</span><br><span class="line">                converterMap.put(converter.convertType(), converter)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"execution(public * com.action.AssetAction.doAction(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aspect</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        Method method = signature.getMethod();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 取 action 方法的第一个参数，将其转化为context</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        Class&lt;?&gt; paramType = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">        ContextConvert contextConvert = converterMap.get(paramType);</span><br><span class="line">        Object obj = joinPoint.getArgs()[<span class="number">0</span>];</span><br><span class="line">        AssetContext assetContext = (AssetContext) contextConvert.apply(obj);</span><br><span class="line"></span><br><span class="line">        opContextHolder.pushStack(assetContext);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            opContextHolder.popStack();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAction</span> <span class="keyword">implements</span> <span class="title">AssetAction</span>&lt;<span class="title">Void</span>, <span class="title">AssetContext</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OpContextHolder contextHolder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AssetContext <span class="title">doAction</span><span class="params">(AssetOpContext assetOpContext, Void param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contextHolder.current();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(<span class="string">"classpath:META-INF/spring/assets-stable.xml"</span>)</span><br><span class="line"><span class="meta">@FixMethodOrder</span>(MethodSorters.NAME_ASCENDING)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextAspectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ILog LOGGER = LogFactory.getLog(ContextAspectTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestAction testAction;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OpContextHolder contextHolder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span>(expected = IllegalStateException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01_beforeAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"调用前应该不存在上下文, thread="</span> + Thread.currentThread().getId() + <span class="string">", thread-name="</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 调用之前，应该没有上下文</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        AssetContext afterInvoke = contextHolder.current();</span><br><span class="line">        Assert.assertNull(afterInvoke);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02_runDoAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AssetOpContext expected = <span class="keyword">new</span> AssetOpContext();</span><br><span class="line">        RandomFieldInjector.inject(expected);</span><br><span class="line"></span><br><span class="line">        LOGGER.info(<span class="string">"expected="</span> + expected);</span><br><span class="line"></span><br><span class="line">        AssetContext inAction = testAction.doAction(expected, <span class="keyword">null</span>);</span><br><span class="line">        LOGGER.info(<span class="string">"inAction="</span> + inAction);</span><br><span class="line"></span><br><span class="line">        Assert.assertNotNull(inAction);</span><br><span class="line">        AssetOpContext actual = convert(inAction);</span><br><span class="line">        LOGGER.info(<span class="string">"actual="</span> + expected);</span><br><span class="line"></span><br><span class="line">        Asserts.assertFieldsEquals(expected, actual, AssetOpContext.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span>(expected = IllegalStateException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03_afterAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"调用后应该不存在上下文, thread="</span> + Thread.currentThread().getId() + <span class="string">", thread-name="</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 调用之后，上下文有收回</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        AssetContext afterInvoke = contextHolder.current();</span><br><span class="line">        Assert.assertNull(afterInvoke);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> AssetOpContext <span class="title">convert</span><span class="params">(AssetContext assetContext)</span> </span>&#123;</span><br><span class="line">        AssetOpContext context = <span class="keyword">new</span> AssetOpContext();</span><br><span class="line">        context.setActionType(assetContext.getEventType());</span><br><span class="line">        context.setEventTime(assetContext.getEventTime());</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>##ThreadLocal的使用场景</p>
<p>ThreadLocal 不是为了解决线程间的共享变量问题的，如果是多线程都需要访问的数据，那需要用全局变量加同步机制。</p>
<p>举几个例子说明一下：</p>
<p>1、比如线程中处理一个非常复杂的业务，可能方法有很多，那么，使用 ThreadLocal 可以代替一些参数的显式传递；</p>
<p>2、比如用来存储用户 Session。Session 的特性很适合 ThreadLocal ，因为 Session 之前当前会话周期内有效，会话结束便销毁。我们先笼统但不正确的分析一次 web 请求的过程：</p>
<p>用户在浏览器中访问 web 页面；<br>浏览器向服务器发起请求；<br>服务器上的服务处理程序（例如tomcat）接收请求，并开启一个线程处理请求，期间会使用到 Session ；<br>最后服务器将请求结果返回给客户端浏览器。<br>从这个简单的访问过程我们看到正好这个 Session 是在处理一个用户会话过程中产生并使用的，如果单纯的理解一个用户的一次会话对应服务端一个独立的处理线程，那用 ThreadLocal 在存储 Session ,简直是再合适不过了。但是例如 tomcat 这类的服务器软件都是采用了线程池技术的，并不是严格意义上的一个会话对应一个线程。并不是说这种情况就不适合 ThreadLocal 了，而是要在每次请求进来时先清理掉之前的 Session ，一般可以用拦截器、过滤器来实现。</p>
<p>3、在一些多线程的情况下，如果用线程同步的方式，当并发比较高的时候会影响性能，可以改为 ThreadLocal 的方式，例如高性能序列化框架 Kyro 就要用 ThreadLocal 来保证高性能和线程安全；</p>
<p>4、还有像线程内上线文管理器、数据库连接等可以用到 ThreadLocal;</p>
<p>5.项目如果使用了线程池，那么小心线程回收后ThreadLocal、InheritableThreadLocal变量要remove,否则线程池回收后，变量还在内存中，后果不堪设想！ </p>
</div><div class="tags"><a href="/tags/java基础/">java基础</a></div><div class="post-nav"><a class="next" href="/2019/08/17/tr-huangshan-blog/">游记博客</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://yuly.pro"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/my-blog/" style="font-size: 15px;">my blog</a> <a href="/tags/markdown/" style="font-size: 15px;">markdown</a> <a href="/tags/my-blog-of-trival/" style="font-size: 15px;">my blog of trival</a> <a href="/tags/java基础/" style="font-size: 15px;">java基础</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/11/06/threadLocal/">ThreadLocal(JDK1.8)刨析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/17/tr-huangshan-blog/">游记博客</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/15/markdown-grammar/">Markdown语法笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/11/my-first-blog/">我的个人博客</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://chpengzh.com/" title="GoodFriend pengzc's blog" target="_blank">GoodFriend pengzc's blog</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">四火的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>